# BMAD ADS Automation Workflow
# Complete automated development workflow for multi-repository development

workflow:
  id: automated-development
  name: BMAD ADS Automated Development
  description: "Complete automated development workflow for implementing requirements across three interconnected repositories"
  type: brownfield
  project_types:
    - multi-repository-development
    - automated-workflow
    - pattern-based-development
    - brownfield-enhancement

  phases:
    - phase: notion_extraction
      agent: virat
      condition: "input is Notion URL or requirement ID"
      steps:
        - step: load_virat_environment
          action: load environment variables from .env file using env-loader.js
          script: "utils/env-loader.js load"
          creates: loaded environment configuration
          notes: "Load NOTION_API_KEY and NOTION_DATABASE_ID from project .env file"
        - step: validate_notion_environment
          action: validate Notion API credentials and database access
          creates: validated Notion connection
          notes: "Verify loaded environment variables are valid"
        - step: parse_notion_identifier
          action: parse Notion URL or requirement ID to extract page identifier
          creates: parsed page identifier
          notes: "Handle both full URLs and requirement IDs (e.g., REQ-1234)"
        - step: extract_requirement_from_notion
          action: extract requirement content from Notion page "Below Comments" section
          script: "notion-integration/scripts/notion-handler.js"
          creates: formatted requirement document (.virat-requirement.md)
          notes: "Extract content from Below Comments section and format for VIRAT"
        - step: store_notion_tracking
          action: store Notion page ID and metadata for later push-back
          creates: .notion-tracking.json with page information
          notes: "Store page ID, URL, and extraction timestamp for documentation push-back"

    - phase: analysis_planning
      agent: virat
      steps:
        - step: requirement_analysis
          action: analyze requirement document and create implementation plan
          creates: implementation plan with repository mapping
          notes: "Parse requirement document (from file or Notion extraction) and identify affected repositories and modules"
        - step: module_identification
          action: identify target modules and patterns from requirement
          creates: module mapping and pattern identification
          notes: "Identify primary and secondary modules affected by requirement"
        - step: dependency_mapping
          action: analyze shared dependencies and impact assessment
          creates: dependency analysis and modification recommendations
          notes: "Identify shared classes, constants, and utilities that need careful handling"

    - phase: repository_intelligence
      agent: virat
      steps:
        - step: repository_crawling
          action: crawl all three repositories to understand current state and patterns
          creates: comprehensive repository state map with patterns and templates
          notes: "Consolidated crawling of irisx-algo, ms-loadapis-ril-final, and irisx-config with pattern analysis"
        - step: pattern_recognition
          action: analyze crawled data to identify patterns and enhance requirements
          creates: pattern classification and enhanced requirements
          notes: "Classify patterns into structural, code, data, configuration, and validation categories"
        - step: loadapi_pattern_analysis
          agent: loadapi-pattern-expert
          action: analyze LoadAPI-specific patterns and denormalization requirements
          creates: LoadAPI pattern analysis and implementation guidance
          notes: "Delegate to LoadAPI Pattern Expert for LoadAPI-specific patterns, denormalization analysis, and implementation guidance"
        - step: config_pattern_analysis
          agent: config-pattern-expert
          action: analyze configuration-specific patterns and cross-repository coordination
          creates: Configuration pattern analysis and implementation guidance
          notes: "Delegate to Configuration Pattern Expert for configuration patterns, SQL view creation, template generation, and cross-repository coordination"
        - step: algorithm_pattern_analysis
          agent: algorithm-pattern-expert
          action: analyze algorithm-specific patterns and module dependencies
          creates: Algorithm pattern analysis and implementation guidance
          notes: "Delegate to Algorithm Pattern Expert for algorithm patterns, module structures, validation frameworks, and module dependency analysis"
        - step: mfp_pattern_analysis
          agent: mfp-pattern-expert
          action: analyze MFP-specific patterns and forecasting algorithms
          creates: MFP pattern analysis and implementation guidance
          notes: "Delegate to MFP Pattern Expert for MFP repository patterns, forecasting algorithms, Python pattern recognition, and environment-specific MFP logic"
        - step: template_generation
          action: generate implementation templates based on discovered patterns
          creates: implementation templates and validation patterns
          notes: "Generate templates and patterns to follow during implementation"

    - phase: story_branch_management
      steps:
        - step: story_creation
          agent: sm-agent
          action: create implementation story using draft command
          creates: detailed user story with acceptance criteria
          notes: "Use SM agent with *draft command and create-next-story.md task"
        - step: branch_creation
          agent: virat
          action: create feature branches from caas-release in all affected repositories
          creates: feature branches with consistent naming
          notes: "Create branches from caas-release with naming convention: feature/{req-id}-{title}"

    - phase: implementation
      agent: dev-agent
      steps:
        - step: code_implementation
          action: implement changes using develop-story command
          creates: modified source files with new functionality
          notes: "Use Dev agent with *develop-story command and strict story file updates"
        - step: configuration_updates
          action: update configuration files across repositories
          creates: updated configuration files
          notes: "Update configuration files in all affected repositories"
        - step: cross_repository_sync
          action: synchronize changes across all three repositories
          creates: synchronized repository state
          notes: "Ensure consistency across Algorithm, LoadAPI, and Config repositories"

    - phase: validation_testing
      agent: qa-agent
      steps:
        - step: implementation_validation
          action: validate implementation using review-qa and run-tests
          creates: validation reports and test results
          notes: "Use QA agent with *review-qa and *run-tests commands"
        - step: quality_assurance
          action: perform comprehensive quality assurance checks
          creates: quality assurance reports
          notes: "Perform comprehensive quality checks and validation"

    - phase: documentation_delivery
      agent: virat
      steps:
        - step: result_documentation
          action: update requirement document with implementation results
          creates: updated documentation with complete implementation details
          notes: "Update original requirement document with results"
        - step: change_summary
          action: create comprehensive change summary
          creates: change summary and delivery documentation
          notes: "Create comprehensive summary of all changes made"

    - phase: notion_push_back
      agent: virat
      condition: "requirement was extracted from Notion"
      steps:
        - step: gather_documentation_files
          action: collect all generated documentation files for push-back
          creates: list of documentation files to upload
          notes: "Find *-ANALYSIS.md, *-IMPLEMENTATION.md, *-PLAN.md, CHANGELOG.md files"
        - step: convert_to_notion_blocks
          action: convert markdown documentation to Notion block format
          creates: Notion-formatted blocks ready for upload
          notes: "Convert markdown files to Notion blocks with proper formatting"
        - step: push_to_notion
          action: upload documentation to original Notion page "Below Comments" section
          script: "notion-integration/scripts/notion-push.js"
          creates: updated Notion page with implementation documentation
          notes: "Create implementation summary toggle with all documentation as nested blocks"
        - step: update_notion_tracking
          action: update tracking file with push completion status
          creates: updated .notion-tracking.json with push timestamp
          notes: "Record push completion, file count, and final status"

  success_criteria:
    - All three repositories have feature branches created
    - All required code changes implemented following existing patterns
    - All validation tests pass
    - Configuration files updated consistently
    - Documentation updated with complete implementation details
    - Implementation completed within 2-hour target
    - If Notion source: Documentation successfully pushed back to original Notion page

  error_handling:
    - Repository access issues: Handle gracefully with fallback options
    - Branch conflicts: Resolve existing branch conflicts
    - Validation failures: Address with appropriate fixes
    - Pattern conflicts: Resolve between requirements and existing patterns
    - Dependency issues: Handle shared class modification impacts

  notes:
    - This workflow implements the complete BMAD ADS Automation system
    - Follows BMAD agent specialization rules strictly
    - Performs actual git operations and repository modifications
    - Uses multi-stage repository crawling for accuracy
    - Implements pattern-based requirement enhancement
    - Maintains consistency across all three repositories
    - Supports both file-based and Notion-based requirements seamlessly
    - Notion integration: Extract → Implement → Push Back (all in one workflow)
