# Core Implementation Rules for VIRAT
# All 45 rules integrated - these MUST guide every action
# Rules are referenced by semantic names for maintainability

# === SEMANTIC RULE REFERENCE MAP ===
# Use these semantic names instead of rule numbers when referencing rules
rule_map:
  # Core Implementation (1-10)
  new_input_integration: 1
  new_output_integration: 2
  new_module_creation: 3
  module_interactions: 4
  shared_infrastructure: 5
  multiple_loadapis_per_table: 6
  data_consistency_structure: 7
  validation_naming: 8
  framework_config: 9
  sql_template_rules: 10
  # Repository Coordination (11-15)
  cross_repo_type_safety: 11
  performance_documentation: 12
  error_handling_testing: 13
  branch_commit_merge: 14
  business_data_quality: 15
  # Pattern Management (16-20)
  args_input_table_standards: 16
  pattern_discovery: 17
  pattern_validation: 18
  pattern_evolution: 19
  pattern_documentation: 20
  # Error Handling & Testing (21-22)
  comprehensive_error_handling: 21
  testing_framework: 22
  # Documentation & Release Management (23)
  documentation_and_release_management: 23
  # Complete Development Flow (24)
  complete_development_flow: 24
  # Class Management (25-34)
  utility_class_management: 25
  objectmaps_usage: 26
  basedata_class: 27
  utiloutputsyncmodule_registration: 28
  abstract_class_modification: 29
  cache_class_usage: 30
  helper_vs_utility_class_decision: 31
  constants_error_message_management: 32
  interim_temporary_data_structure: 33
  cross_module_communication: 34
  # Advanced Patterns (35-43)
  cross_repository_data_migration: 35
  duplicate_loadapi_elimination: 36
  entity_specific_flag_integration: 37
  validation_module_comprehensive_update: 38
  header_consistency_validation: 39
  business_logic_abstraction: 40
  backward_compatibility_aggregation: 41
  coordinated_deployment_management: 42
  upload_configuration_consolidation: 43
  # Critical Patterns (44-45)
  mandatory_file_class_synchronization: 44
  post_deployment_parameter_registration: 45

# === CORE IMPLEMENTATION RULES (1-10) ===
rule_1_new_input_integration:
  steps:
    - Add entries in both __init__ files inside LoadAPI
    - Add validations for new input
    - Input headers denormalized, stored data normalized
    - If folder missing in LoadAPI → find similar LoadAPIs and replicate structure
    - Update sync query & view creation configs (same format as LoadAPI)
    - Update export & template formats to match LoadAPI
    - Add new input definition in module_input.json
  algo_changes:
    - Add entries for filename, SchemaProvider, Row, and File
    - Match file headers with sync queries
    - For new columns → update LoadAPI, sync query, view, export, and template
    - Ensure algorithm consumes new input correctly

rule_2_new_output_integration:
  steps:
    - Update export queries, view creation, and output JSON in config
    - Add entries for Row, File, Filename, and SchemaProvider under UtilOutputSyncModule
    - Match file headers across export & view creation
  new_columns:
    - Modify export, view creation, and Row/File definitions
    - Ensure correct data source linkage for new reports

rule_3_new_module_creation:
  steps:
    - Add submodule entry in relevant group module
    - Submodule must extend AbstractModule
  completely_new_module:
    - Create new group module (extends AbstractUtilModuleGroup)
    - Create submodules (extend AbstractModule)
    - Add entries for Module name, Module provider, Dependent file provider, Dependent modules
    - Create single Args file (shared across all submodules in group)
    - If new inputs/outputs → follow rules 1 & 2

rule_4_module_interactions:
  communication_rules:
    - Between submodules → use common data classes
    - Between modules → Module A saves intermediate files, Module B reads them

rule_5_shared_infrastructure:
  utility_shared_resources:
    - Cache Class for multi-module or multi-view data
    - Helper Class for reusable common methods

rule_6_multiple_loadapis_per_table:
  critical_learning: "A SINGLE TABLE can have MULTIPLE LoadAPIs, exports, and templates"
  discovery_pattern: "ALWAYS search for ALL LoadAPIs/exports/templates for a table, not just one"
  examples:
    - "planogram table → PlanogramLoadApi AND PlanogramDistributionLoadApi"
    - "distribution_store table → DistributionStoreLoadApi AND multiple export templates"
    - "Each LoadAPI serves different business purposes for the same underlying table"
  implementation_rules:
    - "When modifying a table, find ALL related LoadAPIs/exports/templates"
    - "Update ALL relevant LoadAPIs, not just the first one found"
    - "Each LoadAPI may have different validation rules and business logic"
    - "Templates and exports may serve different user personas or use cases"
  search_strategy: "Use comprehensive grep/search patterns to find all references to table name"
  feedback_prevention: "This prevents repeated feedback about missing LoadAPIs/templates"

rule_7_data_consistency_structure:
  header_consistency:
    loadapi: "MASTER_HEADER (denormalized) → DB_HEADER (normalized)"
    algorithm: "getHeaders() → File class headers"
    config: "sync query SELECT → template headers"
  denormalization_cycle:
    critical: "Never mix normalized & denormalized data in the same layer"
    stages:
      user_upload: "Denormalized (style_code, store_code)"
      loadapi: "Normalize → style_id, store_id"
      algorithm: "Normalized only"
      config_export: "Denormalized (style_code, store_code)"
  loadapi_registration:
    mandatory_files: ["LoadAPI Class", "Module __init__.py", "Main __init__.py", "loadapi_provider.py"]
    import_id_format: "import_{module}_{input/output}_{descriptive_name}"
  objectmaps_integration:
    use_objectmaps: ["get_store_to_store_id_map(db)", "get_sku_to_sku_id_map(db)", "get_style_code_to_style_id_map(db)", "get_wh_to_wh_id_map(db)"]
    critical: "Never custom-denormalize — always use maps"

rule_8_validation_naming:
  validation_module:
    requirements: ["Must extend AbstractValidationModule", "Must have @Component annotation", "Implement validate() method", "Register in ValidationModuleNames"]
  naming_conventions:
    filename_constant: "UPPER_SNAKE_CASE (EXPORT_DIST_INPUT_STORE)"
    row_class: "PascalCase + Row (StorePerformanceRow)"
    file_class: "PascalCase + File (StorePerformanceFile)"
    loadapi: "PascalCase + LoadApi (StorePerformanceLoadApi)"
    module: "PascalCase + Module (StorePerformanceModule)"

rule_9_framework_config:
  spring_framework:
    annotations: ["Use @Component (not @Service/@Repository)", "Use @Autowired for DI", "Use @PostConstruct for initialization"]
    extend: ["AbstractModule", "AbstractValidationModule", "AbstractUtilModuleGroup"]
  config_json_updates:
    update_together: ["module_input.json → new sync input config", "module_output.json → new output tables", "upload-files.json → import ID mappings"]
    critical: "Ensure import IDs match LoadAPI & Config"

rule_10_sql_template_rules:
  sql_view_creation:
    pattern: ["Use OPENROWSET for bulk reads", "Define all columns in WITH clause", "Use {{child}} / {{parent}} variables"]
    naming_pattern: "child-input-, child-output-, parent-input-*"
    requirement: "Columns must match template headers"
  template_generation:
    tsv_requirements: ["Name: export_{module}_{type}_template.tsv", "1st row = headers (match LoadAPI MASTER_HEADER)", "Include valid sample data", "Tab-delimited"]

# === REPOSITORY COORDINATION RULES (11-15) ===
rule_11_cross_repo_type_safety:
  cross_repository_coordination:
    development_order: ["Algorithm → create Row/File", "LoadAPI → after Algo ready", "Config → after LoadAPI ready"]
    requirement: "Test integration & version alignment"
  data_type_consistency:
    java: "String / Integer / Double"
    python: "Validation matches Java"
    sql: "WITH clause types match Java/Python"
    template: "Sample reflects correct type"
    critical: "Never mix types (String ↔ Integer)"

rule_12_performance_documentation:
  performance:
    guidelines: ["Use Cache class for shared data", "Process in batches (not per-row)", "Use lazy loading", "Clear memory post-use", "Optimize SQL"]
  documentation:
    requirements: ["Update requirement & change docs", "Add JavaDocs for all public methods", "Maintain changelogs", "Update pattern documentation", "Add cross-repo relationships"]

rule_13_error_handling_testing:
  exception_handling_standards:
    loadapi_requirements: ["All LoadAPI classes must implement exception handling in validate_row() and __get_normalized_data()", "Use self._add_errors() for validation errors", "Rollback failed operations", "Log all exceptions with context"]
  unit_testing:
    requirements: ["All static utility methods → mandatory unit tests", "Minimum 80% coverage for new modules", "Naming: {ModuleName}Test.java", "Location: src/test/java (mirror structure)"]

rule_14_branch_commit_merge:
  branch_management:
    rules: ["Branch from correct base branches per environment", "Format: feature/{req-id}-{description}", "Create branches in all 3 repos simultaneously", "Delete feature branches after merge"]
    environment_detection: "MANDATORY: Detect environment (prod/reliance/phoenix) from requirement document ENV field or header"
    base_branches_by_environment:
      prod:
        algorithm: "caas-release"
        loadapi: "release_optimised"
        config: "caas-staging_fix"
      reliance:
        algorithm: "master-ril"
        loadapi: "caas-ril-uploads"
        config: "master-ril"
      phoenix:
        algorithm: "master-adidas-reliance-prod"
        loadapi: "caas-phoenix-uploads"
        config: "master-adidas-ril"
  commit_message:
    format: "[REQ-{id}] {repository}: {description}"
    requirements: ["Cross-Repo: Reference related commits", "Each commit = atomic, working change"]
  merge_conflict_resolution:
    rules: ["Never force-push shared branches", "Use merge commits to preserve history", "Run full test suite before merging", "Document manual conflict resolutions"]
  dependency_driven_implementation:
    root_cause_analysis: ["Analyze WHY compilation fails - usually dependency issues", "Identify missing imports, unresolved classes, or circular dependencies", "Trace dependency chains to understand impact", "Research existing dependency patterns before implementing"]
    dependency_implementation_strategy: ["Implement missing dependencies following established patterns", "Add required imports and class references", "Ensure proper module registration and wiring", "Validate dependency injection configurations", "Check cross-repository dependency alignment"]
    proper_implementation_approach: ["Never just 'fix' compile errors - understand the business need", "Research existing similar implementations for dependency patterns", "Follow Rule 34 (Cross-Module Communication) for proper dependency management", "Implement complete dependency chain, not just immediate fixes", "Validate that new dependencies align with existing architecture"]
    validation_requirements: ["Compile successfully across all 3 repositories", "Verify all dependencies are properly resolved and registered", "Test dependency injection works correctly", "Ensure no circular dependencies introduced", "Validate cross-repository dependency consistency"]

rule_15_business_data_quality:
  business_rule_validation:
    requirements: ["All business rules = documented + testable", "Ensure consistency across modules", "Validate against historical data", "Perform downstream impact analysis"]
  data_quality_rules:
    checks: ["Implement data quality checks at every stage", "Completeness: Validate full data", "Accuracy: Check against business rules", "Consistency: Across all repositories"]

# === PATTERN MANAGEMENT RULES (16-20) ===
rule_16_args_input_table_standards:
  args_class_definition:
    pattern: "public class [ModuleName]Args extends Args"
    location: "src/main/java/com/increff/irisx/args/"
    field_declaration: ["All fields private", "Standard getter/setter pattern", "Include type validation", "Proper null handling"]
    scope: "One Args class per Group Module (shared across all submodules)"
  args_data_type:
    requirements: ["Use correct Java types (String, Integer, Double, Boolean)", "Match Row class fields", "Validate in setters"]
  args_injection:
    pattern: "@Autowired private [ModuleName]Args [moduleName]Args;"
    initialization: ["Initialize in @PostConstruct", "Pass Args to dependent child modules"]
    sharing: "Same Args instance injected into all submodules within group"
  business_parameter_storage:
    usage: ["Args store all configurable business parameters", "Document each parameter", "Validate ranges"]
  args_usage:
    use_for: ["System-wide config", "Algorithm thresholds", "Environment settings (dev/test/prod)", "Requires deployment for change"]
  input_table_rules:
    use_for: ["Entity-specific data (store/SKU/style)", "User-uploadable data", "Transactional/operational data", "Changes allowed without deployment"]
  hybrid_scenarios:
    business_rules_vary_by_entity: "Input Table"
    system_wide_constant: "Args"
    user_configurable: "Input Table"
    developer_controlled: "Args"

rule_17_18_19_20_pattern_management:
  pattern_discovery: "Research existing patterns before implementation"
  pattern_validation: "Validate new patterns against existing ones"
  pattern_evolution: "Manage pattern changes systematically"
  anti_pattern_prevention: "Prevent implementation of known anti-patterns"
  pattern_documentation: "Document all patterns comprehensively"

# === ERROR HANDLING & TESTING RULES (21-22) ===
rule_21_comprehensive_error_handling:
  multi_level_error_handling: "Implement error handling at all levels"
  rollback_procedures: "Plan rollback strategy for all operations"
  error_recovery: "Implement automatic error recovery where possible"

rule_22_testing_framework:
  comprehensive_testing: "Implement testing at all levels (unit, integration, end-to-end)"
  test_coverage: "Maintain minimum test coverage requirements"
  performance_testing: "Include performance testing in all implementations"
  qa_unit_testing: "Use QA persona to create comprehensive unit tests for all new features"
  business_testing: "Create business scenario tests that validate use cases and value propositions"
  documentation_testing: "Validate that generated documentation accurately reflects implemented features"

# === DOCUMENTATION & RELEASE MANAGEMENT (23) ===
rule_23_documentation_and_release_management:
  feature_documentation: "Generate comprehensive user documentation for all implemented features"
  usage_documentation: "Create step-by-step guides explaining how to use new features"
  change_documentation: "Document what changed and why for stakeholder communication"
  business_release_notes: "Create business-focused release notes with use cases and value propositions"
  technical_release_notes: "Generate technical release notes for developers and system administrators"
  impact_analysis: "Document business impact and expected outcomes of implemented features"

# === COMPLETE DEVELOPMENT FLOW (24) ===
rule_24_complete_development_flow:
  phase_1_requirement_understanding:
    step_1: "Deep Requirement Analysis - Parse requirement document using analyst patterns with intelligent classification"
    step_2: "Repository Pattern Analysis - MANDATORY: Crawl base branches FIRST, then crawl only affected repositories based on classification"
    step_3: "Cross-Dependency Impact Analysis - Find dependencies only within affected repositories"
  intelligent_classification_keywords:
    config_only: ["template", "planogram", "export", "view", "SQL", "query", "JSON config", "configuration", "report format", "output format", "combinations", "filtering"]
    loadapi_only: ["upload", "validation", "denormalization", "import", "file processing", "data ingestion", "ObjectMap"]
    algorithm_only: ["business logic", "calculation", "module", "processing", "algorithm", "computation", "rules engine"]
    cross_repository: ["new input", "new output", "new module", "end-to-end", "complete workflow"]
  phase_2_implementation_planning:
    step_4: "Create Comprehensive Change Plan - List ALL files to be modified across repositories"
    step_5: "Dependency Validation - Verify no breaking changes to existing modules"
  phase_3_development_execution:
    step_6: "Feature Branch Creation - Create feature branches from correct base branches in ACTUAL REPOSITORIES (irisx-algo, ms-loadapis-ril-final, irisx-config)"
    step_7: "Implementation Following Patterns - Implement changes following discovered patterns exactly"
    step_8: "Cross-Dependency Testing - Test all modules that share input/output data"
  phase_4_validation_documentation:
    step_9: "Comprehensive Testing - Unit tests for new static methods"
    step_10: "Documentation & Delivery - Update ONLY the original requirement document with complete implementation details (no separate files)"
  critical_checkpoints:
    - "Base Branch Analysis: ALWAYS crawl correct base branches before starting"
    - "Pattern Compliance: NEVER deviate from discovered patterns without justification"
    - "Cross-Dependency Check: ALWAYS validate impact on modules sharing data"
    - "Repository Coordination: ALWAYS maintain consistency across all repositories"
    - "Complete Documentation: ALWAYS update requirement document with full details"
  failure_modes_to_avoid:
    - "Starting development without pattern analysis"
    - "Creating branches from wrong base branches"
    - "Missing cross-dependency impact analysis"
    - "Incomplete registration updates"
    - "Inconsistent header formats across repositories"
    - "Inadequate testing of shared dependencies"
    - "Missing documentation updates"

# === CLASS MANAGEMENT RULES (25-34) ===
rule_25_utility_class_management:
  when_to_create: ["Common mathematical calculations", "Data transformation logic shared across modules", "File I/O operations that are repeated", "String manipulation functions", "Date/time processing utilities"]
  patterns: ["Static methods only", "Clear, descriptive method names", "Comprehensive JavaDoc documentation", "Unit tests for all public methods", "Located in appropriate package structure"]
  modification_triggers: ["New common functionality needed", "Existing utility method needs enhancement", "Performance optimization required", "Bug fixes in shared logic"]

rule_26_objectmaps_usage:
  when_to_use: ["Converting between Row classes and business objects", "Mapping database results to domain objects", "Transforming input data structures", "Converting between different API formats"]
  patterns: ["One-to-one mapping methods", "Clear source and target type definitions", "Null safety handling", "Validation during mapping", "Consistent naming conventions (mapXToY)"]
  modification_rules: ["Update when Row class structure changes", "Modify when business object fields change", "Enhance when new validation rules added", "Fix when data type mismatches occur"]

rule_27_basedata_class:
  characteristics: ["Core data fields that multiple modules depend on", "Common properties shared across business objects", "Base validation rules", "Standard serialization/deserialization", "Immutable or controlled mutability"]
  modification_triggers: ["New common fields needed across modules", "Validation rules change", "Serialization requirements change", "Performance optimization needed"]
  impact_analysis_required: ["All classes extending BaseData", "All modules using BaseData fields", "Serialization/deserialization logic", "Database schema alignment"]

rule_28_utiloutputsyncmodule_registration:
  registration_requirements: ["Register in ModuleProvider", "Update SchemaProvider if schema changes", "Configure in application context", "Add to module dependency graph", "Update documentation"]
  when_to_modify: ["New output format requirements", "Synchronization logic changes", "Performance optimization needed", "Error handling improvements"]
  validation_checklist: ["All dependent modules still function", "Output format consistency maintained", "Synchronization timing preserved", "Error propagation works correctly"]

rule_29_abstract_class_modification:
  modification_impact: ["ALL implementing classes must be reviewed", "Method signature changes affect all subclasses", "New abstract methods require implementation everywhere", "Behavior changes can break existing functionality"]
  safe_modification_practices: ["Add new methods with default implementations", "Use @Deprecated before removing methods", "Provide migration path for breaking changes", "Update all implementations simultaneously"]
  testing_requirements: ["Test all implementing classes", "Verify contract compliance", "Check polymorphic behavior", "Validate inheritance hierarchy"]

rule_30_cache_class_usage:
  implementation_patterns: ["Thread-safe access patterns", "Appropriate eviction policies", "Memory usage monitoring", "Cache hit/miss metrics", "Proper invalidation strategies"]
  when_to_modify: ["Performance bottlenecks identified", "Memory usage optimization needed", "Cache invalidation logic changes", "New caching requirements"]
  safety_rules: ["Never cache mutable objects directly", "Implement proper synchronization", "Handle cache failures gracefully", "Monitor cache effectiveness", "Document cache behavior clearly"]

rule_31_helper_vs_utility_class_decision:
  utility_classes: ["Pure functions with no state", "Mathematical calculations", "Data format conversions", "String/date manipulations", "Static methods only"]
  helper_classes: ["Stateful operations", "Complex business logic assistance", "Multi-step processes", "Context-dependent operations", "May have instance variables"]
  decision_matrix:
    no_state_needed: "Utility Class"
    requires_configuration: "Helper Class"
    pure_computation: "Utility Class"
    business_context_needed: "Helper Class"

rule_32_constants_error_message_management:
  constants_organization: ["Group related constants in dedicated classes", "Use meaningful names and documentation", "Avoid magic numbers in code", "Maintain version compatibility", "Follow naming conventions"]
  error_message_patterns: ["Centralized error message constants", "Consistent message formatting", "Internationalization support", "Error code standardization", "Context-specific error details"]
  modification_rules: ["Update constants when business rules change", "Maintain backward compatibility for public constants", "Update error messages for clarity", "Coordinate changes across repositories"]

rule_33_interim_temporary_data_structure:
  usage: ["Processing intermediate results", "Multi-stage calculations", "Data transformation pipelines", "Caching intermediate states", "Performance optimization"]
  lifecycle_management: ["Clear creation and cleanup patterns", "Memory usage monitoring", "Proper disposal mechanisms", "Thread safety considerations", "Documentation of lifecycle"]
  modification_triggers: ["Processing logic changes", "Performance optimization needs", "Memory usage concerns", "Data structure evolution"]

rule_34_cross_module_communication:
  communication_patterns: ["Event-driven messaging", "Shared data structures", "Interface-based contracts", "Dependency injection", "Observer patterns"]
  modification_impact: ["Changes affect all communicating modules", "Interface changes require coordination", "Message format changes need versioning", "Timing changes can break workflows"]
  validation_requirements: ["Test all communication paths", "Verify message delivery", "Check error propagation", "Validate data consistency", "Monitor performance impact"]

# === ADVANCED PATTERN RULES (35-43) - DERIVED FROM REQ-1150 LEARNINGS ===
rule_35_cross_repository_data_migration:
  systematic_approach:
    phase_1: "Remove from source (identify all references to source fields)"
    phase_2: "Add to destination with proper validation and processing"
    phase_3: "Update all business logic to use new data source"
    phase_4: "Update all dependent systems (exports, templates, SQL views)"
  data_flow_mapping: ["Map complete flow: user upload → LoadAPI → database → algorithm → exports", "Identify all touch points before starting implementation", "Document data transformation at each stage"]
  critical_validation: ["Trace complete dependency chain before implementation", "Validate data consistency across all stages", "Ensure backward compatibility through aggregation views"]

rule_36_duplicate_loadapi_elimination:
  detection_strategy: ["Search for ALL LoadAPIs related to a table before making changes", "Identify LoadAPIs serving same business purpose", "Look for similar import IDs and table targets"]
  elimination_process: ["Establish single source of truth", "Consolidate functionality into primary LoadAPI", "Update all configuration references", "Remove duplicate LoadAPI files"]
  prevention_measures: ["Document LoadAPI purposes clearly", "Maintain LoadAPI registry", "Review for duplicates during code reviews"]

rule_37_entity_specific_flag_integration:
  integration_pattern: ["Store flags at entity level where they're used, not at global level", "Add flags to business entity classes (e.g., StoreStyle)", "Provide entity-specific flag access methods"]
  implementation_approach: ["Integrate flags during entity creation", "Use flags for entity-specific business logic", "Avoid separate flag lookup structures"]
  performance_optimization: ["Cache flags at most granular level needed", "Provide aggregated access methods for performance", "Initialize flag cache during module startup"]

rule_38_validation_module_comprehensive_update:
  systematic_audit: ["Search for ALL validation modules that reference changed fields", "Update validation logic to use new data source", "Remove obsolete field assignments and validations"]
  update_pattern: ["Remove field assignments from removed fields", "Update validation logic to use new data patterns", "Ensure validation consistency across modules"]
  testing_requirements: ["Test all validation modules after field changes", "Verify validation logic works with new data source", "Ensure no validation gaps introduced"]

rule_39_header_consistency_validation:
  consistency_requirements: ["Headers must match across LoadAPI → SQL view → Export query → Template", "Maintain header order consistency", "Ensure data type consistency across all stages"]
  validation_checklist: ["LoadAPI MASTER_HEADER matches template headers", "SQL view columns match export query SELECT", "Export query headers match template structure"]
  maintenance_approach: ["Create header consistency validation tools", "Document header dependencies", "Automate header consistency checks"]

rule_40_business_logic_abstraction:
  utility_creation: ["Create utility classes for complex business logic parsing", "Encapsulate parsing logic in reusable utilities", "Provide clear documentation and examples"]
  abstraction_patterns: ["Static utility methods for stateless operations", "Clear input/output contracts", "Comprehensive error handling and validation"]
  implementation_example: ["PlanogramFlagUtil for parsing distribution flags", "Utility classes for complex field parsing", "Reusable business logic components"]

rule_41_backward_compatibility_aggregation:
  compatibility_strategy: ["Maintain export compatibility by aggregating granular data", "Provide aggregation views for backward compatibility", "Document compatibility approach"]
  implementation_approach: ["Export queries aggregate granular data to original format", "Maintain same output structure for existing consumers", "Provide migration path for new granular access"]
  validation_requirements: ["Test backward compatibility thoroughly", "Verify existing consumers continue to work", "Document any breaking changes clearly"]

rule_42_coordinated_deployment_management:
  deployment_order: ["Configuration → LoadAPI → Algorithm (dependency order)", "Database schema changes first, then data processing, then business logic"]
  coordination_requirements: ["Consistent feature branch naming across repositories", "Coordinated deployment timing", "Rollback procedures for each repository"]
  branch_management: ["feature/{req-id}-{description} across all repositories", "Coordinate branch creation and merging", "Document cross-repository dependencies"]

rule_43_upload_configuration_consolidation:
  consolidation_approach: ["Update all upload configuration references when eliminating duplicates", "Use single import ID for consolidated LoadAPIs", "Remove obsolete configuration entries"]
  configuration_files: ["upload-files.json import ID mappings", "module_input.json sync configurations", "All references to LoadAPI import IDs"]
  validation_requirements: ["Verify all configuration references updated", "Test upload functionality after consolidation", "Ensure no broken configuration links"]

# === CRITICAL MISSING PATTERN RULE (44) - DERIVED FROM REQ-1175 CRITICAL FIX ===
rule_44_mandatory_file_class_synchronization:
  critical_requirement: "WHENEVER Row class fields are added/modified, corresponding File class MUST be updated"
  real_world_example: "REQ-1175: Added attribute1 to PlanogramOutputRow → MUST update PlanogramOutputFile headers and write method"
  synchronization_patterns:
    row_to_file_mapping: ["Row class field addition → File class header array update", "Row class field addition → File class read/write method update", "Row class structure MUST match File class structure exactly"]
    file_class_updates:
      headers_array: ["Add new field name to getHeaders() array", "Maintain exact order matching Row class fields", "Use consistent naming between Row and File"]
      tsv_files: ["Add to setTokens array in write() method", "Match array position with headers array", "Handle proper data type serialization"]
      parquet_files: ["Add to getSchema() Type array", "Add r.put(fieldName, o.fieldValue) in write() method", "Use correct PrimitiveType for data type"]
  failure_consequences: ["Missing columns in output files", "Serialization failures", "Data corruption", "Runtime exceptions", "Schema mismatches"]
  validation_checklist: ["Search for corresponding File classes when modifying Row classes", "Update headers array", "Update write method", "Update schema for Parquet files", "Test complete file I/O pipeline"]

# === POST DEPLOYMENT PARAMETER RULE (45) - NEW ALGO ARGS REQUIREMENT ===
rule_45_post_deployment_parameter_registration:
  critical_requirement: "WHENEVER new algorithm parameters (Args fields) are added, they MUST be registered in post_deployment.sql AND documented in master.a_description"
  config_repository_location: "irisx-config/export/post_deployment.sql"
  parameter_registration_pattern:
    a_input_insert: "INSERT ignore INTO `a_input` (name, project_id, value, favourite) VALUES ('parameter_name','${project_id}','default_value','0')"
    naming_convention: ["Use snake_case for parameter names", "Match exactly with Args class field names", "Use descriptive parameter names"]
    default_values: ["Provide sensible default values", "Use string format for all values", "Consider business impact of defaults"]
    favourite_flag: ["Set to '1' for critical parameters", "Set to '0' for optional parameters", "Consider user experience in parameter selection"]
  documentation_requirement:
    master_description_inserts: "MUST add 2 INSERT statements per parameter (English + Spanish locales)"
    english_locale_format: "INSERT INTO master.a_description (id, category, dataType, description, locale, module, name, priority, short_description) VALUES ('unique_id', 'Category', 'DATA_TYPE', 'Full description', 'en', 'module_list', 'parameter_name', 'priority_number', 'Short description');"
    spanish_locale_format: "INSERT INTO master.a_description (id, category, dataType, description, locale, module, name, priority, short_description) VALUES ('unique_id+1', 'Configuración', 'DATA_TYPE', 'Spanish description', 'en-mx', 'module_list', 'parameter_name', 'priority_number', 'Spanish short description');"
    documentation_fields:
      id: ["Use sequential unique ID", "English locale uses base ID", "Spanish locale uses base ID + 1"]
      category: ["Use appropriate business category", "Spanish uses 'Configuración' for configuration parameters"]
      dataType: ["BOOLEAN, INTEGER, DOUBLE, STRING based on Args field type", "Must match Java type exactly"]
      description: ["Comprehensive business description", "Explain parameter purpose and impact"]
      locale: ["'en' for English", "'en-mx' for Spanish/Mexican"]
      module: ["Comma-separated list of applicable modules", "Include all modules that use this parameter"]
      name: ["Exact parameter name matching Args field", "Must be identical to a_input name"]
      priority: ["Sequential priority number", "Maintain ordering consistency"]
      short_description: ["Brief user-friendly description", "Question format preferred (e.g., 'Should X be Y?')"]
  implementation_steps:
    args_analysis: ["Identify all new fields in Args classes", "Determine appropriate default values", "Classify parameter importance (favourite flag)", "Determine applicable modules for parameter"]
    sql_generation: ["Generate a_input INSERT statement", "Generate English a_description INSERT", "Generate Spanish a_description INSERT", "Assign unique sequential IDs", "Follow exact SQL format patterns"]
    validation: ["Verify parameter names match Args fields exactly", "Test default values in algorithm execution", "Ensure no duplicate parameter names", "Validate unique ID assignment", "Check module list accuracy"]
  integration_points:
    algorithm_repository: ["Args class field definitions", "Parameter usage in module logic", "Validation and type checking"]
    config_repository: ["post_deployment.sql parameter registration", "master.a_description documentation", "Default value justification"]
  failure_consequences: ["Algorithm fails due to missing parameters", "Runtime exceptions in parameter lookup", "Inconsistent parameter availability across environments", "Manual parameter setup required", "Missing parameter documentation", "UI parameter display issues"]
  validation_checklist: ["Check all new Args fields have corresponding post_deployment entries", "Verify parameter names match exactly", "Test algorithm execution with default values", "Validate SQL syntax and format", "Ensure both English and Spanish documentation exists", "Verify unique ID assignment", "Check module applicability"]
